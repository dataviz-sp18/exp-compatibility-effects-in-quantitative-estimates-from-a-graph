---
title: Do gridlines on a line graph correct for compatibility effects in quantitative
  estimates of change?
author: "Misha Ash"
date: "5/3/2018"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(knitr)
library(tidyverse)
library(stringr)
library(dplyr)
library(data.table)

library(productplots) # for mosaics
library(forcats)
library(ggplot2)
library(cowplot)
library(GGally)
library(psych)

library(modelr)
# library(ggrepel)
library(broom)
library(descr) # for descriptive crosstabs

library(wesanderson)
library(ggthemes)

set.seed(1111)
```

## introduction

This experiment aims to elicit a cognitive bias that derives from a mental metaphor that maps the dimension of emotional valence onto a vertical spatial dimension (e.g., see Dolscheid & Casasanto, [2014](https://pdfs.semanticscholar.org/18f4/662ffd23f10f0f815c3c4d79cc8d45f68ff9.pdf) and [2015](https://www.frontiersin.org/articles/10.3389/fpsyg.2015.01836/full)). A mental metaphor like this may be deployed by representing the values along a non-spatial dimension ranging from negative emotions like sadness to positive emotions like happiness in terms of positions along a vertical spatial dimension ranging from low to high. It is expected that quantitative estimates made from line graphs will be affected by this bias such that incompatible graphs---that is, graphs representing a decrease in a positively valenced phenomenon like happiness or an increase in a negatively valenced phenomenon like sadness---will inflate error rates relative to compatible graphs.

* *null hypothesis 1*: The mean error will not differ between compatible and incompatible conditions.
* *alternative hypothesis 1*: The mean error will be lower for compatible than incompatible conditions.

As reported by [Heer and Bostock (2010)](http://vis.stanford.edu/files/2010-MTurk-CHI.pdf), gridlines can improve accuracy when not spaced too tightly. To the extent that accuracy is affected by compatibility effects, then, this bias may be mitigated by gridlines.

* *null hypothesis 2*: The mean error will not differ between conditions with and without an additional gridline.
* *alternative hypothesis 2*: The mean error will be lower in the condition with additional gridlines.

## design & methods

The study is organized around a 2x2x2x3 design: 

  * valence: happiness (positive), sadness (negative)
  * direction: increasing, decreasing
  * grid lines: 0 and 1 (mid-line added at 50)
  * city name: Oswa, Escor, Aflos

A set of 24 stimuli graphs is generated by crossing these factors (8 x 3 for each city):
```{r conditions, include = FALSE}
direction <- c("increasing", "decreasing")
valence <- c("happiness", "sadness")
gridlines <- c(0, 1)
#city <- c("Oswa", "Escor", "Aflos")
n <- seq(1:8)

conditions <- CJ(direction, valence, gridlines) %>%
  setnames("V1", "direction") %>%
  setnames("V2", "valence") %>%
  setnames("V3", "gridline") #%>%
  #setnames("V4", "city")

(kable(conditions))
```

Valence and direction are crossed for two compatible conditions (increasing happiness and decreasing sadness) and two incompatible conditions (decreasing happiness and increasing sadness). All stimulus graphs have labels for the minimum and maximum of the scale (0 to 100), and the half in the gridline present condition have an additional label at 50 with a horizontal grid line.

```{r stim data for examples, include = FALSE}
min_value <- base::sample(5:28, 1, replace = FALSE)
mid_value <- base::sample(39:61, 1, replace = FALSE)
max_value <- base::sample(72:95, 1, replace = FALSE)

data_source <- c(min_value, mid_value, max_value) %>%
  as_data_frame() %>%
  mutate(increasing = c(2015, 2016, 2017)) %>%
  mutate(decreasing = c(2017, 2016, 2015))
```

```{r dec_hap_Alfos_nogrid, include = FALSE}
dec_hap_Alfos_nogrid <- data_source %>%
  
  ggplot(aes(decreasing, value)) +
  geom_line(size = 0.4) +
  geom_point() +

  scale_y_continuous(limits = c(0, 100), breaks = c(0, 100), expand = c(0, 0)) +
  scale_x_continuous(limits = c(2014.9, 2017.1), breaks = c(2015, 2016, 2017)) +
  
    theme_light() +
    theme(panel.grid.major.x = element_blank(), # remove vertical grid lines
        panel.grid.minor.x = element_blank(), # remove vertical grid lines
        panel.grid.minor.y = element_blank(), # remove minor horizontal grid lines
        #panel.grid.major.y = element_line(size = 0.5),
        panel.border = element_blank(),
        axis.line = element_line(size = 0.15),
        
        plot.title = element_text(margin = margin(t = 0, r = 0, b = 20, l = 0)),
        axis.title.y = element_text(margin = margin(t = 0, r = 15, b = 0, l = 0)), 
        axis.title.x = element_text(margin = margin(t = 15, r = 0, b = 0, l = 0)),
        axis.text.x = element_text(margin = margin(t = 5, r = 0, b = 0, l = 0)), 
        axis.ticks.x = element_line()) +
  
        ggtitle('Happiness in Alfos') +
        xlab('') +
        ylab('Happiness Score')
```

```{r dec_hap_Alfos_wgrid, include = FALSE}
dec_hap_Alfos_wgrid <- data_source %>%
  
  ggplot(aes(decreasing, value)) +
  geom_line(size = 0.4) +
  geom_point() +

  scale_y_continuous(limits = c(0, 100), breaks = c(0, 50, 100), expand = c(0, 0)) +
  scale_x_continuous(limits = c(2014.9, 2017.1), breaks = c(2015, 2016, 2017)) +
  
    theme_light() +
    theme(panel.grid.major.x = element_blank(), # remove vertical grid lines
        panel.grid.minor.x = element_blank(), # remove vertical grid lines
        panel.grid.minor.y = element_blank(), # remove minor horizontal grid lines
        #panel.grid.major.y = element_line(size = 0.5),
        panel.border = element_blank(),
        axis.line = element_line(size = 0.15),
        
        plot.title = element_text(margin = margin(t = 0, r = 0, b = 20, l = 0)),
        axis.title.y = element_text(margin = margin(t = 0, r = 15, b = 0, l = 0)), 
        axis.title.x = element_text(margin = margin(t = 15, r = 0, b = 0, l = 0)),
        axis.text.x = element_text(margin = margin(t = 5, r = 0, b = 0, l = 0)), 
        axis.ticks.x = element_line()) +
  
        ggtitle('Happiness in Alfos') +
        xlab('') +
        ylab('Happiness Score')
```

```{r inc_hap_Alfos_nogrid, include = FALSE}
inc_hap_Alfos_nogrid <- data_source %>%
  
  ggplot(aes(increasing, value)) +
  geom_line(size = 0.4) +
  geom_point() +

  scale_y_continuous(limits = c(0, 100), breaks = c(0, 100), expand = c(0, 0)) +
  scale_x_continuous(limits = c(2014.9, 2017.1), breaks = c(2015, 2016, 2017)) +
  
    theme_light() +
    theme(panel.grid.major.x = element_blank(), # remove vertical grid lines
        panel.grid.minor.x = element_blank(), # remove vertical grid lines
        panel.grid.minor.y = element_blank(), # remove minor horizontal grid lines
        #panel.grid.major.y = element_line(size = 0.5),
        panel.border = element_blank(),
        axis.line = element_line(size = 0.15),
        
        plot.title = element_text(margin = margin(t = 0, r = 0, b = 20, l = 0)),
        axis.title.y = element_text(margin = margin(t = 0, r = 15, b = 0, l = 0)), 
        axis.title.x = element_text(margin = margin(t = 15, r = 0, b = 0, l = 0)),
        axis.text.x = element_text(margin = margin(t = 5, r = 0, b = 0, l = 0)), 
        axis.ticks.x = element_line()) +
  
        ggtitle('Happiness in Alfos') +
        xlab('') +
        ylab('Happiness Score')
```

```{r inc_hap_Alfos_wgrid, include = FALSE}
inc_hap_Alfos_wgrid <- data_source %>%
  
  ggplot(aes(increasing, value)) +
  geom_line(size = 0.4) +
  geom_point() +

  scale_y_continuous(limits = c(0, 100), breaks = c(0, 50, 100), expand = c(0, 0)) +
  scale_x_continuous(limits = c(2014.9, 2017.1), breaks = c(2015, 2016, 2017)) +
  
    theme_light() +
    theme(panel.grid.major.x = element_blank(), # remove vertical grid lines
        panel.grid.minor.x = element_blank(), # remove vertical grid lines
        panel.grid.minor.y = element_blank(), # remove minor horizontal grid lines
        #panel.grid.major.y = element_line(size = 0.5),
        panel.border = element_blank(),
        axis.line = element_line(size = 0.15),
        
        plot.title = element_text(margin = margin(t = 0, r = 0, b = 20, l = 0)),
        axis.title.y = element_text(margin = margin(t = 0, r = 15, b = 0, l = 0)), 
        axis.title.x = element_text(margin = margin(t = 15, r = 0, b = 0, l = 0)),
        axis.text.x = element_text(margin = margin(t = 5, r = 0, b = 0, l = 0)), 
        axis.ticks.x = element_line()) +
  
        ggtitle('Happiness in Alfos') +
        xlab('') +
        ylab('Happiness Score')
```

```{r example stims, echo = FALSE}
plot_grid(dec_hap_Alfos_nogrid, 
          dec_hap_Alfos_wgrid, 
          inc_hap_Alfos_nogrid, 
          inc_hap_Alfos_wgrid, 
          labels = "AUTO", ncol = 2, 
          align = 'v', axis = 'l')
```


## method
Each visualization displays the same three data points in ascending or descending order. The data value triplet used across the graphs is randomly sampled from its respective third of the 0 - 100 range Â±5 (to keep the value from being directly on a grid line and force estimation). The method used by the base R sampling function is analogous to Cleveland and McGill's use of a "uniform random number generator" (1984, p. 539). Resulting stimulus graphs were saved in a .png format via ggsave with uniform dimensions (width = 7, height = 5) and imported to Qualtrics with a fixed aspect ratio and 750 px width.

The framing of each graph was used to elicit compatibility effects by activating a valenced interpretation of what the quantities represent. Prior to being presented with the target stimulus, participants read the following instructions:

> "The next screen will display a graph of annual [happiness/sadness] scores for the city of [Oswa/Escor/Aflos] over the last three years. The graph will be shown for 20 seconds. Study it carefully during this time. You will then be asked a question about this graph. Please answer the question as quickly but accurately as possible. When you are ready, proceed to view the graph."

To increase the possibility of seeing an effect of valence, fictional city names are used as a control variable. People vary in the valence and strength of their associations with concepts represented by words. For example, the name "Ludwig" might trigger strong positive feelings for someone who has fond memories of positive experiences with someone named Ludwig, which may affect how the happiness or sadness of Ludwig is interpreted. Alternatively, someone who has never known a Ludwig will likely be much more neutral in their affective response to this name, or their affective response may be colored by associations activated by resemblence with similar sounding words, such as "wig," or by their memories of the music of Ludwig van Beethoven or the arguments of Ludwig Wittgenstein. To mitigate and control for world knowledge effects on valence, the graphs will be presented as being about change in an annual happiness or sadness score in a fictional city (participants are not informed about the fictive status of the city and the data). Three city names were generated on the [Fantasy Name Generators website](http://www.fantasynamegenerators.com/country_names.php#.Wup3DlMvzOR) (each two syllables; aforementioned).
  
The radomization logic of the stimulus conditions was implemented in Qualtrics (see survey flow in repository materials for more information). After being presented with the stimulus graph for 20 seconds (proceeding prior to timer elapsing was disabled and occurred automatically once timer elapsed), participants made an an estimate of the change between the first and last year plotted by using a slider. The survey began with a multiple-choice qualification task and terminated if the final question was answered incorrectly, which probed participants' understanding of the task by asking about the difference between minimum and maximum values on a graph with 3 gridlines and all points plotted directly on gridlines. 

Given the exploratory nature of the current experiment, a one-shot, between-subjects design is used. The study will consist of one HIT with one of 24 possible conditions, randomly assigned and counter-balanced. The study aims to obtain 480 observations, all from distinct participants (ballot box stuffing was disabled in Qualtrics to mitigate multiple responses from the same participant). Although within-subjects designs can increase power for a given sample size, the comparability (and power) gained would require either using the same values for stimuli across conditions, which is prone to order effects and would require extensive counter-balancing of an already complex design or different values across conditions that vary between participants to converge on comparable means. This would require a larger sample, a larger stimulus set, or both. 

## results

```{r qualtrics dataset 1, include = FALSE, eval = FALSE}
# ingest data
qualtrics_batch_1 <- read_csv("~/R/Data Viz/exp-compatibility-effects-in-quantitative-estimates-from-a-graph/data/Judging changes_2018-05-04_1623.csv", skip = 1)
```

```{r qualtrics dataset 2, include = FALSE}
# ingest data
qualtrics_batch_2 <- read_csv("~/R/Data Viz/exp-compatibility-effects-in-quantitative-estimates-from-a-graph/data/Judging changes_2018-05-06.csv", skip = 1)
```

```{r mturk dataset 1, include = FALSE, eval = FALSE}
# ingest data
mturk_batch_1 <- read_csv("~/R/Data Viz/exp-compatibility-effects-in-quantitative-estimates-from-a-graph/data/Batch_3219791_batch_results_2018-05-04_1623.csv")
```

```{r check responses, include = FALSE, eval = FALSE}
mturk_qual_code <- full_join(qualtrics_batch_1, mturk_batch_1, by = c("MTurkCode" = "Answer.surveycode")) %>%
  select("Duration (in seconds)", "Response ID", "MTurkCode", "WorkTimeInSeconds") 

mturk_qual_code <- mturk_qual_code %>%
  filter(WorkTimeInSeconds < 30 | is.na(MTurkCode))
```

```{r tidy, include = FALSE}

tidy_qualtrics <- qualtrics_batch_2 %>%
  
  filter(Finished == 1, 
         .[,18] == 2 | .[,71] == 2, # min value qualification for increasing (QID5, QID14)
         .[,19] == 4 | .[,72] == 4, # max value qualification for increasing (QID8, QID15)
         !is.na(.[,123]), # direction value not missing
         !is.na(.[,124]), # valence value not missing
         !is.na(.[,125]), # gridline value not missing
         !is.na(.[,126])) %>% # city value not missing
  
  select("Response ID",
         "User Language",
         "Duration (in seconds)",
         "Indicate how much the Happiness Score changed between 2015 and 2017. - Happiness Score Change", 
         "Indicate how much the Sadness Score changed between 2015 and 2017. - Happiness Score Change", 
         "direction", 
         "valence", 
         "gridline", 
         "city") %>%
  
  data.table::setnames(old = c("Response ID", "User Language", "Duration (in seconds)", "Indicate how much the Happiness Score changed between 2015 and 2017. - Happiness Score Change", "Indicate how much the Sadness Score changed between 2015 and 2017. - Happiness Score Change"), 
                       new = c("id", "language", "duration_sec", "happy_change", "sad_change")) %>%
  
  gather(key = score, value = est_change, happy_change, sad_change) %>%
  filter(!is.na(est_change)) %>%
  select(-score) %>%

  # add compatibility condition
  mutate(compatibility = 
           ifelse((.$direction == "increasing" & .$valence == "happiness" |
             .$direction == "decreasing" & .$valence == "sadness"), 1, 0)) %>%
  
  # calculate numeric estimate errors
  mutate(act_change = ifelse(.$direction == "decreasing", -77, 77)) %>%
  mutate(diff_change = as.double(est_change) - act_change) %>%
  
  # calculate absolute value estimate errors
  mutate(abs_change = 77) %>%
  mutate(error = abs((abs(as.double(est_change)) - abs_change)))

#fix city names
tidy_qualtrics <- mutate(tidy_qualtrics, 
                                 city = str_replace(tidy_qualtrics$city, "Alfos", "Aflos"))

```

```{r error se table, include = FALSE}
error_se <- tidy_qualtrics %>%
  dplyr::select(error, compatibility, gridline, direction) %>%
  data.table()


tbl_err_compat_grid_dir <- error_se[, list(mean = mean(error), 
                               sd = sd(error),
                               se = sqrt(var(error)/length(error)),
                               se_test = sd(error)/length(error),
                               # 95% confidence intervals of the mean (&plusmn;2se)
                               ci_min = mean(error) - 2*(sd(error)/length(error)),
                               ci_max = mean(error) + 2*(sd(error)/length(error))),
                        by=list(compatibility, gridline)]


```

Based on participant ID, observations from `r length(unique(tidy_qualtrics$id))` Turkers were included in the analysis. (Disqualified or otherwised unfinished submissions were excluded.) All participants were English speakers. 

Error rate does not appear to be related to city name, so this control variable may be excluded from analysis.
```{r city name boxplot, echo = FALSE}
qplot(x = as_factor(city), y = error, data = tidy_qualtrics, 
      geom = c("boxplot", "jitter"), alpha = 0.4, fill = city) +
  # aesthetic adjustments
  theme_minimal() +
      # change color scheme of fill colors
      scale_fill_manual("city", 
                       values = wes_palette(n = 4, name = "Zissou"),
                       labels = c("no", "yes")) +
  
      # add labels
      labs(x = "city name (valence control variable)", 
           y = "estimate error (absolute value)", fill = "city",
           title = "errors by city name") +
  
      # adjust theme parameters
      theme(panel.grid.major.x = element_blank(),
          legend.position = "none",
          axis.title.y = element_text(margin = margin(t = 0, r = 15, b = 0, l = 0)),
          axis.title.x = element_text(margin = margin(t = 15, r = 0, b = 0, l = 0)),
          axis.text.x = element_text(margin = margin(t = -10, r = 0, b = 0, l = 0)))
```

A first-pass analysis of errors via general linear mixed effects model suggests compatibility effects were not elicited and gridlines did not affect estimates.
```{r glm error, echo = FALSE}
# general linear model
error_glm1 <- glm(error ~ compatibility * gridline, 
                              data = tidy_qualtrics)
summary(error_glm1)
```

It is possible that this analysis is inadequate, however, particularly given the highly right-skewed distribution of error values:
```{r error distribution, echo = FALSE}
ggplot(tidy_qualtrics, aes(error)) +
  geom_histogram(aes(y = ..density..), binwidth = .5, color = "grey", fill = "light blue") +
  geom_density(alpha = 0.7, size = 0.01, fill = "light blue") +
  theme_light() +
  ggtitle('density distribution of errors') +
  xlab('error estimate (absolute value)') +
  ylab('frequency')
```
Based on the current analysis, both null hypotheses were not rejected. Further analysis, perhaps with log error, may be more revealing.

Interestingly, a linear mixed effects model (controlling for random effect of time spent on survey) shows a significant effect of direction, which suggests that estimates of decreases are more error-prone when made from a line graph. This may be an interesting avenue for further research.
```{r lme direction_gridline, echo = FALSE, message = FALSE}
library(lme4)
library(lmerTest)
# general linear mixed effects model
error_glmem <- lmer(error ~ direction * 
                              gridline + (1|duration_sec), 
                              data = tidy_qualtrics)
anova(error_glmem)
summary(error_glmem)

```

```{r direction boxplot, echo = FALSE}
qplot(x = as_factor(direction), y = error, data = tidy_qualtrics, 
      geom = c("boxplot", "jitter"), alpha = 0.4, fill = direction) +
  # aesthetic adjustments
  theme_minimal() +
      # change color scheme of fill colors
      scale_fill_manual("direction", 
                       values = wes_palette(n = 4, name = "Zissou"),
                       labels = c("no", "yes")) +
      
      # add labels
      labs(x = "direction of change", 
           y = "estimate error (absolute value)", fill = "direction",
           title = "estimate error greater for decreases than increases") +
  
      # adjust theme parameters
      theme(panel.grid.major.x = element_blank(),
          legend.position = "none",
          axis.title.y = element_text(margin = margin(t = 0, r = 15, b = 0, l = 0)),
          axis.title.x = element_text(margin = margin(t = 15, r = 0, b = 0, l = 0)),
          axis.text.x = element_text(margin = margin(t = -10, r = 0, b = 0, l = 0)))
```





```{r error by city, include = FALSE}

ggplot(tidy_qualtrics, aes(as_factor(city), error)) + 
  stat_summary(fun.y = "mean", geom = "bar", fill =  "#628B9F") + 
  stat_summary(fun.data = mean_se, geom = "errorbar", width = 0.2)
```

```{r exploratory glance, include = FALSE}

ggplot(tidy_qualtrics, aes(gridline, error)) + 
  stat_summary(fun.y = "mean", geom = "bar", fill =  "#628B9F") + 
  stat_summary(fun.data = mean_se, geom = "errorbar", width = 0.2) +
  facet_wrap(~ compatibility)


# 
mean_accuracy_compat_grid <- tidy_qualtrics %>%
  dplyr::select(error, compatibility, gridline) %>%
  dplyr::group_by(compatibility, gridline) %>%
  dplyr::summarize(mean_error = sum(error)/length(error), n = length(error)) 

```


